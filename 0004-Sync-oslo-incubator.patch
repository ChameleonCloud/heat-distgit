From 368f34cb3fc60696aef07c6e4c9435a372d81520 Mon Sep 17 00:00:00 2001
From: Thomas Herve <thomas.herve@enovance.com>
Date: Tue, 12 May 2015 16:42:08 +0200
Subject: [PATCH] Sync oslo incubator

Sync with oslo incubator at commit
0fb9dcd54d4e08d9ac8f9764a38c68911b287200
This fixes an issue with heat engine shutdown.

Closes-Bug: #1454987
Change-Id: Ie29a7781eb06ee58eb347c924b9110100ddd56f9
(cherry picked from commit c29af45c336c892a1093aa66277302706948eed5)
---
 heat/openstack/common/service.py | 56 ++++++++++++++++++++++++----------------
 1 file changed, 34 insertions(+), 22 deletions(-)

diff --git a/heat/openstack/common/service.py b/heat/openstack/common/service.py
index 47cef74..fffe491 100644
--- a/heat/openstack/common/service.py
+++ b/heat/openstack/common/service.py
@@ -18,6 +18,7 @@
 """Generic Node base class for all workers that run on hosts."""
 
 import errno
+import io
 import logging
 import os
 import random
@@ -25,14 +26,6 @@ import signal
 import sys
 import time
 
-try:
-    # Importing just the symbol here because the io module does not
-    # exist in Python 2.6.
-    from io import UnsupportedOperation  # noqa
-except ImportError:
-    # Python 2.6
-    UnsupportedOperation = None
-
 import eventlet
 from eventlet import event
 from oslo_config import cfg
@@ -59,15 +52,15 @@ def _is_daemon():
     # http://www.gnu.org/software/bash/manual/bashref.html#Job-Control-Basics
     try:
         is_daemon = os.getpgrp() != os.tcgetpgrp(sys.stdout.fileno())
+    except io.UnsupportedOperation:
+        # Could not get the fileno for stdout, so we must be a daemon.
+        is_daemon = True
     except OSError as err:
         if err.errno == errno.ENOTTY:
             # Assume we are a daemon because there is no terminal.
             is_daemon = True
         else:
             raise
-    except UnsupportedOperation:
-        # Could not get the fileno for stdout, so we must be a daemon.
-        is_daemon = True
     return is_daemon
 
 
@@ -199,18 +192,30 @@ class ServiceWrapper(object):
 
 
 class ProcessLauncher(object):
-    def __init__(self):
-        """Constructor."""
+    _signal_handlers_set = set()
+
+    @classmethod
+    def _handle_class_signals(cls, *args, **kwargs):
+        for handler in cls._signal_handlers_set:
+            handler(*args, **kwargs)
 
+    def __init__(self, wait_interval=0.01):
+        """Constructor.
+
+        :param wait_interval: The interval to sleep for between checks
+                              of child process exit.
+        """
         self.children = {}
         self.sigcaught = None
         self.running = True
+        self.wait_interval = wait_interval
         rfd, self.writepipe = os.pipe()
         self.readpipe = eventlet.greenio.GreenPipe(rfd, 'r')
         self.handle_signal()
 
     def handle_signal(self):
-        _set_signals_handler(self._handle_signal)
+        self._signal_handlers_set.add(self._handle_signal)
+        _set_signals_handler(self._handle_class_signals)
 
     def _handle_signal(self, signo, frame):
         self.sigcaught = signo
@@ -222,7 +227,7 @@ class ProcessLauncher(object):
     def _pipe_watcher(self):
         # This will block until the write end is closed when the parent
         # dies unexpectedly
-        self.readpipe.read()
+        self.readpipe.read(1)
 
         LOG.info(_LI('Parent process has died unexpectedly, exiting'))
 
@@ -230,15 +235,12 @@ class ProcessLauncher(object):
 
     def _child_process_handle_signal(self):
         # Setup child signal handlers differently
-        def _sigterm(*args):
-            signal.signal(signal.SIGTERM, signal.SIG_DFL)
-            raise SignalExit(signal.SIGTERM)
-
         def _sighup(*args):
             signal.signal(signal.SIGHUP, signal.SIG_DFL)
             raise SignalExit(signal.SIGHUP)
 
-        signal.signal(signal.SIGTERM, _sigterm)
+        # Parent signals with SIGTERM when it wants us to go away.
+        signal.signal(signal.SIGTERM, signal.SIG_DFL)
         if _sighup_supported():
             signal.signal(signal.SIGHUP, _sighup)
         # Block SIGINT and let the parent send us a SIGTERM
@@ -329,8 +331,8 @@ class ProcessLauncher(object):
 
     def _wait_child(self):
         try:
-            # Block while any of child processes have exited
-            pid, status = os.waitpid(0, 0)
+            # Don't block if no child processes have exited
+            pid, status = os.waitpid(0, os.WNOHANG)
             if not pid:
                 return None
         except OSError as exc:
@@ -359,6 +361,10 @@ class ProcessLauncher(object):
         while self.running:
             wrap = self._wait_child()
             if not wrap:
+                # Yield to other threads if no children have exited
+                # Sleep for a short time to avoid excessive CPU usage
+                # (see bug #1095346)
+                eventlet.greenthread.sleep(self.wait_interval)
                 continue
             while self.running and len(wrap.children) < wrap.workers:
                 self._start_child(wrap)
@@ -383,8 +389,14 @@ class ProcessLauncher(object):
                 if not _is_sighup_and_daemon(self.sigcaught):
                     break
 
+                cfg.CONF.reload_config_files()
+                for service in set(
+                        [wrap.service for wrap in self.children.values()]):
+                    service.reset()
+
                 for pid in self.children:
                     os.kill(pid, signal.SIGHUP)
+
                 self.running = True
                 self.sigcaught = None
         except eventlet.greenlet.GreenletExit:
